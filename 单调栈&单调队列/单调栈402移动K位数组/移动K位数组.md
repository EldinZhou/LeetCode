#402.移掉K位数组

######题目:
给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。


######思考:
本题仍然采用单调栈的方法，但是有一点变化，此次我们不仅仅是用栈来存储全局比较的量，而是直接用单调栈来存储我们最终想要的K位数组。
这一点是比较新的变化，为什么可以用单调栈来直接存储最终的结果呢？对于本题我们想要得到一个最小的数字，与字母序最小的意思一致，
那么我们可以去向单调栈这个角度去考虑。我们可以注意到，如果一个数字想要比较小，那么尽可能在高位的数据要更小一点。也就是说
当我们遍历num数组的每一位时，如果当前位的数字比前面的还要小，我们就可以考虑取代前面的数字，让这个较小的数字成为高位数，这样
我们的结果相对来说也比较小。但是这个题目中有一个移掉k位数组的限制，也就是说我们不能一直进行比较移除操作，而是有限制的，我们
要维护这样的一个限制变量，比如令```lim = k```，然后对lim变量每次进行出栈操作的时候减1，直到lim变量=0的时候意味着操作结束，
我们此时就需要终止操作，这个时候单调栈内存储的值在一般情况下即为所求。

那么什么时候这个一般情况的规律会被打破呢？我们发现当如果输入的数组是一个递增序列或者为一个不减序列，那么我们就很难办。始终我法进入到
对比出栈对lim减1的操作中，导致我们得到的数组依然是原来的数组。不过这种情况，我们很好处理，只需要直接截短原数组(字符串)，
即 ```ans = num[:len(num)-k]```。

除此之外，我们还需要注意一个特殊情况，就是我们需要考虑比如数字中出现前面冗余的0时，举个例子，比如我们对于```000235```，我们
就需要除去前面的000直接输出235，此情况需要和只输出0的情况区分开。


代码如下:

```go
func removeKdigits(num string, k int) string {
    var stack []byte
	tr := k
	if len(num) <= k {
		return "0"
	}

	for _, ch := range num {
		//利用栈来存储最终的值
		for len(stack) >= 1 && stack[len(stack)-1] > ch && k > 0 {
			stack = stack[:len(stack)-1]
			k--
		}
		stack = append(stack, ch)
	}

	if k > 0 {
		str := string(stack[:len(num)-tr])
		//去除00XXX的情况
		for len(str) > 1 && str[0] == 48 {
			str = str[1:]
		}
		return str
	}

	//去除00XXX的情况
	res := ""
	if len(stack) < 1 {
		res = "0"
	}
	res = string(stack)

	for len(res) > 1 && res[0] == 48 {//string[index]->byte(uint8)
		res = res[1:]
	}
	return res
}

```

#单调栈-84. 柱状图中最大的矩形

#####【题目】给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。


此题的关键是想到如何得到最大的矩形，因为矩形的面积是由宽度*高度决定的。但是对于宽度和高度这两个参量其都是变化的，而非定值。
那么我们是否存在可能来固定其中一个值呢。这个题在入手想到单调栈之前，需要先结合场景想到如何求解最大的矩形。我们可以发现待选高度
随着对heights数组的遍历是不断变化的。那我们其实可以把求解最大的矩形面积，想象成对于heights数组中的每个元素，也就是每个高度，
我们都会获得一个以这个高度为高度的矩形，而对于维持这个高度的最大矩形也就是找出这个高度下的最大宽度。这样每个高度我们都会
得到一个当前高度下的最大面积。最终只需要比较出这些面积中最大的面积，即为所求。

那么有了上述分析后，我们如何得到最大宽度呢。首先我们可以想到什么情况下矩形会维持以当前高度作为高这个参量呢？不难发现，只有
矩形满足矩形内的所有高度条的高度都比当前的heights[i]高或者相等才可以。因为一旦高度条小于它，矩形就无法再以这个高度为高，
会选择更小的那个高度。那么这个问题就转化为求解到距离当前高度最近的比当前高度矮的高度条的索引。这个索引是可以位于当前高度条
的左侧和右侧的。而左右两个索引的差值-1即为所求。但是这会存在边界条件。两种情况，一个是当前高度是整个数组中最小的情况，那么
就意味着没有任何高度可以比它还要矮。那这个时候怎么处理呢？我们考虑这是最矮的情况的话，就意味着它附近的所有高度条如果组成矩形
一定是以它的高度作为矩形高，那么我们就可以假定在数组外侧存在一个比它还要矮的，那也就是索引为-1或者n的情况。我们这里的高度最小
不一定是对于整个数组的，也可以是这个高度条的左侧或者右侧的高度条都比它高或者等高的情况。另一个边界条件就是在数组的边界，即
索引为0或者len(heights)-1，这种情况它们的左侧或者右侧没有任何元素，那么他们就是最矮的，也是符合我们刚才阐述的那种情况。

那么讨论完边界条件和转化后的思路，我们要想用什么算法或者数据结构能够高效地解决这个题呢？这就引入到我们的单调栈，此题是利用
左右两个单调栈然后在遍历heights数组的同时维护分别这两个单调递减栈(单调递减栈表示从栈顶到栈底，元素大小依次递减)，然后在维护的
模板下完成对每个元素左侧和右侧距离它最近的比它小的元素索引的存储。当然左右遍历的顺序是不同的，一个是正序遍历另一个是倒序遍历。

那么为什么单调递减栈可以有效地解决这个问题呢？因为单调递减栈始终是维护当前栈顶元素是整个栈中最大的元素，但是对于每个新遇见的
数组元素我们都需要将它入栈。而为什么是单调栈不是单调队列呢，因为栈的栈顶元素是LIFO，是最新遍历的，距离当前元素最近的，符合我们的题目期待。
那么情景就是，我们的栈中存在一个(栈底->栈顶)索引依次向当前元素索引靠近，值依次递增的序列。而对于当前元素如果想找到最近的
比它小的高度元素，就可以依次试探。首先最近这个关键词，就可以想到栈。而取小就可以想到递增这个关键词。为什么呢？因为还是一般的思路，
对于这个题目期待，高度元素值小和距离当前元素近是题目所期望的高价值条件。而二者不可兼得，如果兼得的话，(栈和队列一般是维护全局的量)
就会出现这样一种情况，一个元素很小而且离当前元素heights[i]还特别近，那么后续的元素就没有存在(入栈)的意义了，所以才是一个
单调递减栈(栈顶元素值大)。

所以一步步拆解，就可以得到想要的答案，并且熟用单调栈和单调队列的模板(维护全局单调栈/队列的模板)。

```go

var stack []int

for i := 0; i < len(heights); i++ {

    //维护单调栈->单调递减栈
    for len(stack) >= 1 && stack(len(stack)-1) >= heights[i] {
        stack = stack[:len(stack)-1]//栈顶出栈
    }

    //<-工作代码
    //...
    //非空->栈顶元素就是要找的比当前元素还小的最近元素索引
    //空->没找到,意味着当前元素在这一侧没有比他还小的元素，存入-1或者n
    //工作代码->

    //入栈
    stack = append(stack, heights[i])//每个被遍历到的元素入栈
}

```

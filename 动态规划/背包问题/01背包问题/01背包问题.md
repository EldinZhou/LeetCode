##01背包问题

    对于01背包问题，作为动态规划中十分基础也十分重要的部分，需要格外注意。其实各种背包问题的基础，尤其要掌握二维
    动态规划序列和一维滚动数组进行优化。

##什么是01背包问题
01背包问题就是给定N个不同的物品，每个物品有且仅有1个，且其重量/体积为wi,即为w[i],其对应的价值为v[i]。而已知现有的背包总容积为
V。问如何放置这些物品才能使背包中所装物品的总价值最大。

这是一个NP完全问题，什么是NP完全问题就是不能通过简单的逻辑运算或者关系求解出来，需要借助穷举+检测来求得的一类问题，动态规划就是其中的一种。
那么对于这个问题如何求解呢。

首先我们要知道**动态规划的五部曲**:

1. 首先明确dp数组的定义，确定是采用一维数组还是二维数组。
2. 确定状态转移方程，也就是dp[i]或者dp[i][j]与其他状态之间的转移方程。
3. 明确初始化，搞清楚边界条件对应的dp值。
4. 遍历顺序: 前序遍历 or 倒序遍历; 背包和物品的嵌套顺序。
5. 输出最终的答案，一般是dp[n.size()-1]或者是二维数组的最末端值。

那么对于本题该如何处理呢?
首先明确dp数组的定义，我们想要得到总价值最大的解，那我们的dp数组表示含义应当是当前背包中所有可选物品组合下的最大价值。
也就是表示的是价值，那么我们需要知道dp数组中的索引表示什么含义。我们看这道题想一下总价值由什么决定的呢？我们要注意
dp问题的风格是逐渐遍历+状态转移，所以我们要有能够表示状态的参量。从直觉来看，我们会发现总价值肯定与物品有关，
那么物品的属性就是其价值和重量/体积。那么作为状态量的话，也就是第几个物品，对于一般性来说，可以设为第i个物品。
而逐级遍历这种风格，我们可以想到逐渐放大或者是缩小背包的容量，将背包容量从0递增到V或者从V递减到0。那么我们就可以
设这个参量为j。那么定义也就呼之欲出了，即为dp[i][j],其表示对于选定第i个物品时，当前背包容积为j的情况下背包能够
承载或者容纳下的最大价值。

那么有了这个定义之后，我们该怎么进一步明确状态转移方程呢。我们继续来看定义，由动态规划的一般风格可以想到，动态
规划通常对于一个一般状态会去想如何能够得到这个状态，或者这个状态与其他状态的关系。那么对于这个题目，我们可以联想到如果想要得到
或者对于第i个物品，我们如何变动到其他状态呢，或者怎么由其他状态变换到该状态呢。因为我们是逐渐遍历物品数目的，可以
想到其肯定是由第i-1个物品的情况变换而来的。那么有哪些变换情况呢？第一种是我们选定了该物品，并放入背包，但是前提是该物品
的容积或者代价不能超过现有背包容器的容量。另一种就是我们不选这个物品，直接采用之前的第i-1状态下的放置方法，这也是可以的。
故而有两种情况，因为要最大价值，所以两种情况取最大值。
所以状态转移方程为:dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]]+w[i])

初始化的话，对于dp[0][j]来说，意味着第0个物品也就是索引为0的物品这个的值初始化可以设置为物品0的价值，但是注意
不是所有的都可以初始化为这个价值的，必须满足j>=物品0的体积/重量。那另一部分的初始则是当j=0的时候，意味着背包的容积
为0，那么自然dp[i][0]也是0。

到此我们的状态转移方程，dp数组的定义和初始化都完成了。接下来就是遍历顺序，对于二维dp来说，无所谓遍历顺序，因为
它的行和列都是独立的，不存在用某一行一直来存储dp的数值。也就不存在遍历顺序的问题，那么就可以怎么遍历都ok。

最终答案应该是dp[N-1][V]。

```go

//01背包问题
//Golang中没有内置的int类型的max函数
func maxValue(N int, V int, w []int, val []int) int{
    dp := make([][]int, N)
	for i := 0; i < N; i++ {
		dp[i] = make([]int, V+1)
	}
	//初始化dp数组
	for j := 0; j < V+1 ; j++{
		if j >= w[0] {
			dp[0][j] = w[0]
		}
	}
	//状态转移方程
	for i := 1; i < N; i++ {
		for j := 0; j < V+1 ; j++{
			if j >= w[i] {
				dp[i][j] = int(math.Max(float64(dp[i-1][j]),float64(dp[i-1][j-w[i]] + val[i])))
			} else{
				dp[i][j] = dp[i-1][j]
			}
		}
	}
	return dp[N-1][V]
}

```
为什么可以使用滚动数组优化呢？因为状态转移数据中i只与i-1那一行有关。

对于此题，更简化的方法是利用滚动数组实现空间复杂度的降低，即是需要采用一维数组即可。所谓的滚动数组就是反复重复
使用上述二维数组中的某一行进行存储dp[i][j]的所有状态。这样即可以实现空间复杂度的降低，可以理解成只取矩阵中的一行
而所有信息是将二维数组中上一行的信息拷贝到这个一维数组中。因为我们最后需要的也只是最末尾的值，所以这么做是可行的。
也就是忽略掉其中不需要的状态，让每一行继承上一行的状态。而这个继承还是更新是通过max函数比较实现的，但是注意的是
我们的比较对象都是借助上一行的旧值，而非用已经更新过涵盖这行的新值，所以采用倒序遍历，这个点在动态规划中经常使用，
要重点理解。那么这么说是什么意思呢。就是因为我们采用了dp[j-w[i]]和dp[j]我们寄希望在我们访问到j的时候j前面的数据
是没有被该行更新过的，就还是i-1的数据，而非i的数据。所以如果是正序遍历，那么我们使用dp[j-w[i]]这样的值时，其中
j-w[i]比j的索引小，其会在j之前被更新成i对应的值，而非i-1的，那么就会产生错误。也就是说01背包中每个物品只能被使用一次，
而当你如果之前就遍历过一次的话再进行遍历一次那么这个物品就重复使用了，违背了01背包的题干。

而对于为什么先遍历物品后遍历背包，其实也很好理解，因为物品是需要被固定的，就是我们是按照每一行每一行去拷贝的，如果行
的信息不固定，我们如何能够得到这一行中所有列的信息呢。如果调换遍历顺序，则会导致最终只返回其中一个物品的dp数组。

(滚动数组的核心思想就是将矩阵压缩成一维dp数组)

```golang

func maxValueSimple(N int, V int, w []int, val []int) int {
    //利用滚动数组的思想实现一维dp解决此题
	dp := make([]int, V+1)

	for i := 0; i < N; i++ {
		for j := V; j >= w[i]; j-- {
			dp[j] = int(math.Max(float64(dp[j]), float64(dp[j-w[i]] + val[i])))
		}
	}
	return dp[V]
}

```

>Reference: https://www.bilibili.com/video/BV1BU4y177kY?from=search&seid=16280646124977285134&spm_id_from=333.337.0.0

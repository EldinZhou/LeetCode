# rand随机数系列题目

此部分会涉及两种类型题目(知识点:拒绝采样，等比数列等)

通用的表达式为:

此类型题的核心思路在于抓住设计随机函数的思想即为让定义域内的所有随机数出现的概率相等，即等概率随机数(找到相应的数来映射成相等概率)

randm()与randn()之间的关系:

1. ***<u>m > n:</u>***

如果是m比n小的情况有如下: 可以直接利用randm()生成randn()。一个默认的条件是randm()会生成[1,m]的整数随机数，randn()可以生成[1,n]的整数随机数。所以这种题的一般思路为利用randm()直接生成1～m个随机数，然后取前n个随机数，然后对于生成的[n+1,m]的随机数，当生成在这个区间的随机数采用拒绝采样的方式，重新调用randm()函数直到它生成一个落在[1,n]区间内的随机数才退出循环。

代码示意:

```go
//此处仍以rand10()生成rand7()为例
func rand10() int {
    for {
        num := rand7()
        if num <= 7 {
            return num
        }
    }
}
```

***i)*** 如何证明这个是等概率的:

首先我们需要知道这个程序的逻辑，也就是取[1,10]内的数字，如果在[1,7]这个区间内就会直接输出，而只有落在[8,10]这个区间内才会继续运行直到生成落在前一个区间的数字为止。那么如果我们想得到[1,7]内的某个数(这么做无需做对随机数的处理，比如求余等，直接输出即可)，有如下几种方式，一种是第一次直接随机数就生成了该随机数，概率为1/10。
$$
P(i, i∈[1,7]) = 1/10 + 1/10*(3/10) + 1/10*(3/10)² + 1/10*(3/10)³ + 1/10*(3/10)^k, k = n-1
$$
很显然，上面的公式为等比数列，公比为3/10，利用等比数列求和可得:

> $$
> Sn = a1/1-q
> $$

则有如下的表达式:
$$
P(i) = 1/10*(1+(3/10)*1/(1-3/10)) = 1/10 * 10/7 = 1/7
$$
***ii)***那么另一个比较关键的问题是rand10()函数调用次数的期望怎么求呢?

其实也很简单只要在等比数列的每一项上×n即可，即为:
$$
P(i) = 7/10*1 + 7/10*(3/10)*2 + 7/10*(3/10)² *3 + 7/10*(3/10)³ *4 + 7/10*(3/10)^k *n, k = n-1
$$

> 形式如下的
> $$
> n*q^k,  k = n-1
> $$
> 数列求和可以使用错位相减，直接给出如下的公式:
> $$
> c_n = (a*n+b)*q^k, k = n-1
> S_n = (A*n+B)*q^n + C
> $$
>
> $$
> A=a/(q-1), B = (b-A)/(q-1), C=-B
> $$

注意这块要用的是7/10而不是1/10，因为针对的是rand10()调用的次数，也就是rand10()需要调用的情况，而对于[1,7]生成的随机数是不需要再额外调用的。那么代入可以得到，注意这里涉及到∞/∞型极限，因为分母的增速更快，所有为0。解得
$$
A= -10/7， B=-100/49, C=100/49
$$
那么最后的结果即为:
$$
E=7/10*100/49 = 10/7
$$
一个简洁的公式，可以记忆如下:
$$
E(randm()) = 公式中randm()出现的次数*(len([1,n])/len([1,m]))的倒数
$$
也就是
$$
E(randm()调用次数) = 公式中randm()出现的次数*m/n
$$
更一般的表示:
$$
E(randm()调用次数) = 公式中randm()出现的次数*可以映射到[1,n]中的f(m)范围/f(m)的整体范围
$$


2. <u>***m < n***:</u>

举个例子比如利用rand7()生成rand10()

这种情况下，就要借助K进制的思想，利用合适位数的K进制数来制定合适的范围包含住所要求的n，当然存在优化的方法->让更多的K进制表示的随机数映射成[1,n]的数字。而多少位就表示需要用到多少个randK()或者randm()。

***i)*** 如何处理[1,m]的随机函数randm()生成[1,n]的等概率随机数

例. 7比10小，显然1位的7是肯定无法包含10的，那我们就想到2位。值得注意的是对于K位m进制数，其取值范围是
$$
[0,m^k-1]
$$
那么可以发现2位的7进制的取值范围是[0,48]，可以涵盖[1,10]内的所有数。

为了提高rand7()的利用率则可以将[1,40]内的数字通过求余加1的方式映射到[1,10]中。

那么如何表达成K进制呢？
$$
num = (randm()-1)*m + (randm()-1)
$$
当然可能不止是2位就可以解决，如果是用7表示100呢?

所以就需要考虑k位
$$
num = (randm()-1)*m^g, g = k-1 + ... + (randm()-1)*m^2 + (randm()-1)*m + (randm()-1)
$$
代码如下:

```go
func rand10() int { //要求等概率生成[1,10]
    for {
        num := (rand7()-1)*7 + (rand7()-1)
        if num >= 1 && num <= 40 {
            return num%10 + 1 //注意一定要+1, 否则10就变成了0 不符合要求
            //原因是num∈[1,40]不加1的画就变成1~9,0
            //+1的话 每一位错后一为变成2~10,1,符合要求
        }
    }
}
```

***ii)*** 求randm()调用次数的期望
$$
E = 2*(40/49)^a, a =-1 = 2.45
$$
这个也符合我们上面提到的一般形式的期望求解公式。